// scripts/sheets/items/equipment-sheet.mjs

import {
  ITEM_RANK_KEYS,
  DAMAGE_TYPE_KEYS,
  WEAPON_CATEGORY_KEYS,
  WEAPON_TYPES_BY_CATEGORY,
  ARMOR_CLASS_KEYS,
  ARMOR_TYPES_BY_CLASS
} from "../../../config/items.mjs";

const { HandlebarsApplicationMixin } = foundry.applications.api;

export class HwfwmEquipmentSheet extends HandlebarsApplicationMixin(
  foundry.applications.sheets.ItemSheetV2
) {
  static DEFAULT_OPTIONS = foundry.utils.mergeObject(super.DEFAULT_OPTIONS, {
    classes: ["hwfwm-system", "sheet", "item", "equipment"],
    position: { width: 640, height: 620 },
    form: {
      submitOnChange: true,
      closeOnSubmit: false
    }
  });

  static PARTS = {
    form: {
      template: "systems/hwfwm-system/templates/item/equipment-sheet.hbs"
    }
  };

  /**
   * Coerce a value that might be:
   * - Array               -> return as-is
   * - { "0": {...}, ... } -> convert to array in numeric order
   * - anything else       -> []
   */
  _coerceIndexedToArray(value) {
    if (Array.isArray(value)) return value;

    if (value && typeof value === "object") {
      const keys = Object.keys(value).filter((k) => /^\d+$/.test(k));
      if (!keys.length) return [];
      keys.sort((a, b) => Number(a) - Number(b));
      return keys.map((k) => value[k]);
    }

    return [];
  }

  _ensureMinRows(arr, factory, min = 1) {
    const out = Array.isArray(arr) ? arr : [];
    while (out.length < min) out.push(factory());
    return out;
  }

  _titleCaseFromKey(key) {
    const s = String(key ?? "");
    if (!s) return "";
    return s.charAt(0).toUpperCase() + s.slice(1);
  }

  /** @override */
  async _prepareContext(options) {
    const context = await super._prepareContext(options);

    context.item = this.document;
    context.system = this.document.system ?? {};

    context.equipmentTypes = [
      { value: "weapon", label: "Weapon" },
      { value: "armor", label: "Armor" },
      { value: "misc", label: "Misc" }
    ];

    context.attributesList = [
      { value: "power", label: "Power" },
      { value: "speed", label: "Speed" },
      { value: "spirit", label: "Spirit" },
      { value: "recovery", label: "Recovery" }
    ];

    const sys = context.system;

    // ----- Safe normalization (sheet-side) -----
    sys.equipped = !!sys.equipped;

    sys.itemRank ??= "normal";
    sys.description ??= "";
    sys.notes ??= "";

    sys.weapon ??= {};
    sys.armor ??= {};
    sys.misc ??= {};

    sys.weapon.category ??= "";
    sys.weapon.weaponType ??= "";
    sys.weapon.damagePerSuccess ??= 0;
    sys.weapon.range ??= 0;
    sys.weapon.actionCost ??= 0;
    sys.weapon.damageType1 ??= "";
    sys.weapon.damageType2 ??= "";
    sys.weapon.damageType3 ??= "";

    sys.armor.value ??= 0;
    sys.armor.armorType ??= "";
    sys.armor.armorName ??= "";

    sys.misc.armor ??= 0;

    sys.adjustments ??= {};
    sys.adjustments.attributes ??= {};
    sys.adjustments.resources ??= {};

    for (const a of context.attributesList) {
      sys.adjustments.attributes[a.value] ??= {};
      sys.adjustments.attributes[a.value].flat ??= 0;
    }

    const ensurePctFlat = (k) => {
      sys.adjustments.resources[k] ??= {};
      sys.adjustments.resources[k].pct ??= 0;
      sys.adjustments.resources[k].flat ??= 0;
    };
    const ensureFlat = (k) => {
      sys.adjustments.resources[k] ??= {};
      sys.adjustments.resources[k].flat ??= 0;
    };

    ensurePctFlat("lifeForce");
    ensurePctFlat("mana");
    ensurePctFlat("stamina");

    ensureFlat("trauma");
    ensureFlat("pace");
    ensureFlat("reaction");
    ensureFlat("defense");
    ensureFlat("naturalArmor");

    // IMPORTANT: preserve numeric-key objects by coercing to arrays
    sys.adjustments.specialties = this._ensureMinRows(
      this._coerceIndexedToArray(sys.adjustments.specialties),
      () => ({ type: "", key: "" }),
      1
    );

    sys.adjustments.affinities = this._ensureMinRows(
      this._coerceIndexedToArray(sys.adjustments.affinities),
      () => ({ key: "" }),
      1
    );

    sys.adjustments.resistances = this._ensureMinRows(
      this._coerceIndexedToArray(sys.adjustments.resistances),
      () => ({ key: "" }),
      1
    );

    // ----- Branch flags -----
    const type = (sys?.type ?? sys?.category ?? "weapon").toString();
    context._ui = {
      type,
      isWeapon: type === "weapon",
      isArmor: type === "armor",
      isMisc: type === "misc"
    };

    // ---------------------------------------------------------
    // Option lists (now wired to config/items.mjs)
    // ---------------------------------------------------------

    // Item rank options (if you want to render as options later; HBS currently hardcodes)
    context.itemRankOptions = ITEM_RANK_KEYS.map((k) => ({
      value: k,
      label: this._titleCaseFromKey(k)
    }));

    context.weaponCategoryOptions = WEAPON_CATEGORY_KEYS.map((k) => ({
      value: k,
      label: this._titleCaseFromKey(k)
    }));

    // Weapon types depend on selected category
    const selectedWeaponCategory = String(sys.weapon.category ?? "");
    const weaponTypes =
      selectedWeaponCategory && WEAPON_TYPES_BY_CATEGORY[selectedWeaponCategory]
        ? WEAPON_TYPES_BY_CATEGORY[selectedWeaponCategory]
        : [];

    context.weaponTypeOptions = weaponTypes.map((name) => ({
      value: name,
      label: name
    }));

    // Armor class options
    context.armorClassOptions = ARMOR_CLASS_KEYS.map((k) => ({
      value: k,
      label: this._titleCaseFromKey(k)
    }));

    // Armor types depend on selected class (armorType)
    const selectedArmorClass = String(sys.armor.armorType ?? "");
    const armorTypes =
      selectedArmorClass && ARMOR_TYPES_BY_CLASS[selectedArmorClass]
        ? ARMOR_TYPES_BY_CLASS[selectedArmorClass]
        : [];

    context.armorTypeOptions = armorTypes.map((name) => ({
      value: name,
      label: name
    }));

    // Damage types (shared list for 1/2/3)
    context.damageTypeOptions = DAMAGE_TYPE_KEYS.map((k) => ({
      value: k,
      label: this._titleCaseFromKey(k)
    }));

    // ---------------------------------------------------------
    // Existing catalogs for specialties/affinities/resistances
    // ---------------------------------------------------------
    const cfg = CONFIG["hwfwm-system"] ?? {};
    const specialtyCatalog = cfg.specialtyCatalog ?? {};
    const affinityCatalog = cfg.affinityCatalog ?? {};
    const resistanceCatalog = cfg.resistanceCatalog ?? {};

    const specialtyTypeOrder = ["power", "speed", "spirit", "recovery"];
    const specialtyTypeLabels = {
      power: "Power",
      speed: "Speed",
      spirit: "Spirit",
      recovery: "Recovery"
    };

    const typesFound = new Set();
    const specialtiesByType = {};

    for (const [key, meta] of Object.entries(specialtyCatalog)) {
      const rawAttr = String(meta?.attribute ?? "").trim();
      if (!rawAttr) continue;

      const t = rawAttr.toLowerCase();
      if (!specialtyTypeOrder.includes(t)) continue;

      typesFound.add(t);
      specialtiesByType[t] ??= [];
      specialtiesByType[t].push({ value: key, label: meta?.name ?? key });
    }

    for (const t of Object.keys(specialtiesByType)) {
      specialtiesByType[t].sort((a, b) => String(a.label).localeCompare(String(b.label)));
    }

    context.specialtyTypeOptions = specialtyTypeOrder
      .filter((t) => typesFound.has(t))
      .map((t) => ({ value: t, label: specialtyTypeLabels[t] ?? t }));

    context.specialtiesByType = specialtiesByType;

    const toOptions = (catalog) =>
      Object.entries(catalog)
        .map(([key, meta]) => ({ value: key, label: meta?.name ?? key }))
        .sort((a, b) => String(a.label).localeCompare(String(b.label)));

    context.affinityOptions = toOptions(affinityCatalog);
    context.resistanceOptions = toOptions(resistanceCatalog);

    // Finalize
    context.system = sys;
    return context;
  }

  /** @override */
  _onRender(context, options) {
    super._onRender(context, options);

    const el = this.element;
    if (!el) return;

    // Click delegation (Add/Remove row)
    this._boundClick ??= this._handleClick.bind(this);
    el.removeEventListener("click", this._boundClick);
    el.addEventListener("click", this._boundClick);

    // Change delegation (force-save array row edits reliably)
    this._boundChange ??= this._handleChange.bind(this);
    el.removeEventListener("change", this._boundChange);
    el.addEventListener("change", this._boundChange);
  }

  async _handleClick(event) {
    const btn = event.target?.closest?.("[data-action]");
    if (!btn) return;

    const action = btn.dataset.action;
    const index = Number(btn.dataset.index);

    switch (action) {
      case "add-specialty-row":
        return this._addRow("system.adjustments.specialties", { type: "", key: "" });

      case "remove-specialty-row":
        return this._removeRow("system.adjustments.specialties", index, { type: "", key: "" });

      case "add-affinity-row":
        return this._addRow("system.adjustments.affinities", { key: "" });

      case "remove-affinity-row":
        return this._removeRow("system.adjustments.affinities", index, { key: "" });

      case "add-resistance-row":
        return this._addRow("system.adjustments.resistances", { key: "" });

      case "remove-resistance-row":
        return this._removeRow("system.adjustments.resistances", index, { key: "" });

      default:
        return;
    }
  }

  async _handleChange(event) {
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;

    const name = target.getAttribute("name") ?? "";

    // Handle repeatable arrays (existing behavior)
    if (name.startsWith("system.adjustments.")) {
      const m = name.match(
        /^system\.adjustments\.(specialties|affinities|resistances)\.(\d+)\.(type|key)$/
      );
      if (!m) return;

      const [, group, idxStr, field] = m;
      const index = Number(idxStr);
      if (!Number.isFinite(index) || index < 0) return;

      const value =
        target instanceof HTMLInputElement ||
        target instanceof HTMLSelectElement ||
        target instanceof HTMLTextAreaElement
          ? target.value
          : "";

      const path = `system.adjustments.${group}`;

      // Read and coerce current value to a real array
      const raw = foundry.utils.getProperty(this.document, path);
      let current = this._coerceIndexedToArray(foundry.utils.deepClone(raw));

      // Ensure row exists
      while (current.length <= index) {
        if (group === "specialties") current.push({ type: "", key: "" });
        else current.push({ key: "" });
      }

      current[index] ??= group === "specialties" ? { type: "", key: "" } : { key: "" };
      current[index][field] = value;

      if (group === "specialties" && field === "type") {
        current[index].key = "";
      }

      await this.document.update({ [path]: current });
      return;
    }

    // Handle dependent dropdown clearing (weapon/armor)
    // - If weapon category changes => clear weaponType
    if (name === "system.weapon.category") {
      await this.document.update({
        "system.weapon.weaponType": ""
      });
      return;
    }

    // - If armor class changes => clear armorName
    if (name === "system.armor.armorType") {
      await this.document.update({
        "system.armor.armorName": ""
      });
      return;
    }
  }

  async _addRow(path, row) {
    const raw = foundry.utils.getProperty(this.document, path);
    const current = this._coerceIndexedToArray(foundry.utils.deepClone(raw));
    current.push(foundry.utils.deepClone(row));
    await this.document.update({ [path]: current });
  }

  async _removeRow(path, index, fallbackRow) {
    const raw = foundry.utils.getProperty(this.document, path);
    let current = this._coerceIndexedToArray(foundry.utils.deepClone(raw));

    if (Number.isFinite(index) && index >= 0 && index < current.length) {
      current.splice(index, 1);
    }

    if (current.length < 1) current.push(foundry.utils.deepClone(fallbackRow));
    await this.document.update({ [path]: current });
  }
}
